\documentclass[10pt,letterpaper]{article}

\usepackage[margin=1in]{geometry}
\usepackage{newtxtext,newtxmath}
\usepackage[final,protrusion=true,expansion=true]{microtype}
\usepackage{graphicx,booktabs,caption,enumitem,titlesec,titling}
\setlength{\parskip}{0pt}
\setlength{\parindent}{1.2em}
\titleformat{\section}{\bfseries}{\thesection}{0.6em}{}   
\titlespacing*{\section}{0pt}{6pt}{3pt}
\setlist{nosep,leftmargin=*,itemsep=0pt,topsep=2pt}
\captionsetup{font=small,labelfont=bf,aboveskip=4pt,belowskip=0pt}
\setlength{\tabcolsep}{5pt}
\raggedbottom
\pagestyle{empty}

\begin{document}

\begin{center}
\textbf{James Rogan, 261157151. Fall 2025}\\
\textbf{ECSE 324 Lab 3 Report}\\
\textbf{Comprative analysis of polling and interupts/timers in ARMv7 Assembly}
\end{center}

\section{Introduction}
An interactive rotating hex display was implemented in \textit{ARMv7 assembly} using both polling and interrupts/timers and profiled on \textit{CPUlator}. 

\section{Methodology}

\subsection{Time Fraction Measurement}

To measure what fraction of time is spent on different activities, we use the total \textit{instructions executed} as a proxy for elapsed time. While not perfectly accurate (since different instructions take different cycles on real hardware), the emulator uniformly reports instruction counts, making this a practical metric.

\subsubsection{Measurement Approach}

The methodology uses CPUlator's debugger breakpoints to establish instruction count checkpoints at key program locations:

\begin{enumerate}
    \item \textbf{Identify key code regions}:
    \begin{itemize}
        \item Interrupt service routine (ISR) entry point
        \item ISR exit point
        \item Slider switch polling loop entry
        \item Slider switch polling loop exit
        \item Main/IDLE code regions
    \end{itemize}

    \item \textbf{Place strategic breakpoints}: Set breakpoints at entry and exit points of each region of interest.

    \item \textbf{Record instruction counts}: Note the cumulative instruction count displayed by CPUlator at each breakpoint.

    \item \textbf{Calculate region instruction counts}:
    \begin{itemize}
        \item Instructions in ISR = (ISR exit count) -- (ISR entry count)
        \item Instructions in polling = (polling exit count) -- (polling entry count)
        \item Instructions in user/IDLE code = Total -- Instructions in ISR -- Instructions in polling
    \end{itemize}

    \item \textbf{Calculate time fractions}:
    \begin{align}
        \text{Fraction}_{\text{ISR}} &= \frac{\text{Instructions}_{\text{ISR}}}{\text{Total Instructions}} \\
        \text{Fraction}_{\text{polling}} &= \frac{\text{Instructions}_{\text{polling}}}{\text{Total Instructions}} \\
        \text{Fraction}_{\text{IDLE/user}} &= \frac{\text{Instructions}_{\text{IDLE/user}}}{\text{Total Instructions}}
    \end{align}
\end{enumerate}

\subsubsection{Practical Implementation}

In CPUlator:
\begin{enumerate}
    \item Run the program to a representative steady state (allow several cycles of activity)
    \item Set a breakpoint at the start of the ISR
    \item Record the starting instruction count before sampling begins
    \item Sample for a fixed duration (e.g., 1,000,000 or 10,000,000 total instructions)
    \item Place breakpoints within interrupt handlers and polling loops
    \item Let the program run to completion while collecting checkpoint data
    \item Calculate the instruction deltas for each region
\end{enumerate}

This approach leverages the emulator's cycle-accurate instruction counting to provide reproducible measurements without requiring external profiling tools.

\section{Results}

Instruction count measurements were taken at strategic breakpoints during a representative execution cycle. Over 377 total instructions (from instruction count 398 to 775), the following time distributions were observed:

\begin{table}[h]
\centering
\caption{Instruction count deltas and computed time fractions}
\begin{tabular}{lrr}
\hline
\textbf{Category} & \textbf{Instructions} & \textbf{Fraction} \\
\hline
Servicing interrupts (ISR + return) &  20 & 5.3\% \\
Polling slider switches &  8 & 2.1\% \\
IDLE/user code &  349 & 92.6\% \\
\hline
\textbf{Total} & \textbf{377} & \textbf{100\%} \\
\hline
\end{tabular}
\end{table}

The ISR itself (SERVICE\_IRQ to EXIT\_IRQ) executed 17 instructions, with an additional 3 instructions for return overhead. Polling of slider switches consumed 4 instructions per execution, whether or not a switch change was detected. The bulk of execution time (92.6\%) was spent in user code and IDLE loops, including 271 instructions dedicated to servicing the detected switch change event.

\section{Discussion}

This measurement reveals that the interrupt-driven approach allocates only 5.3\% of processor time to interrupt servicing, demonstrating efficient ISR design. The ISR is kept minimal, deferring the actual switch change handling to user code running at normal priority. Polling overhead is negligible at 2.1\% per cycle.

When extrapolated to continuous operation, a processor running this code indefinitely would spend approximately 5.3\% of its cycles servicing interrupts, 2.1\% polling switches, and 92.6\% executing user and IDLE code. This distribution is favorable for responsive systems, as it minimizes interrupt latency impact while preserving processor availability for user tasks.

\section{Conclusion}

The interrupt-based implementation of the rotating hex display efficiently balances responsiveness and processor utilization. The minimal ISR overhead (5.3\%) allows the system to remain responsive to switch input while dedicating the majority of processor cycles to user code execution. This approach demonstrates the effectiveness of interrupt-driven architecture for real-time embedded systems.

\end{document}
